#!/usr/bin/env bash
set -euo pipefail
IFS=$'\n\t'

DEV_DIR="${DEV_DIR:-$HOME/dev}"
STATE_ROOT="$HOME/.ralph/state"
MAX_ITERS_DEFAULT=6
MAX_ITERS="${MAX_ITERS:-$MAX_ITERS_DEFAULT}"
DEV_DIR_ABS=""
RALPH_LOG_MODE="${RALPH_LOG_MODE:-stream}"
RALPH_LOG_DIR="${RALPH_LOG_DIR:-}"
RALPH_AUTO_COMMIT="${RALPH_AUTO_COMMIT:-1}"
RALPH_AUTO_PUSH="${RALPH_AUTO_PUSH:-1}"
RALPH_GIT_REMOTE="${RALPH_GIT_REMOTE:-origin}"
RALPH_GIT_BRANCH="${RALPH_GIT_BRANCH:-}"
RUN_AUTO_COMMIT="$RALPH_AUTO_COMMIT"
RUN_AUTO_PUSH="$RALPH_AUTO_PUSH"
RALPH_LAST_NEW_COMMITS=0
RALPH_LAST_PUSHED=0

if [[ ! "$MAX_ITERS" =~ ^[0-9]+$ ]] || [[ "$MAX_ITERS" -lt 1 ]]; then
  MAX_ITERS="$MAX_ITERS_DEFAULT"
fi

usage() {
  cat <<'USAGE'
ralph: development loop runner for projects under ~/dev

Usage:
  ralph pick
  ralph run [--no-commit] [--no-push] <project>
  ralph goal <project>
  ralph progress <project>
  ralph all [--no-commit] [--no-push]

Environment:
  DEV_DIR    Override the default projects directory (default: ~/dev)
  MAX_ITERS  Max iterations for ralph run (default: 6)
  RALPH_LOG_MODE  Output mode: stream, quiet, log, log_only (default: stream)
  RALPH_LOG_DIR   Log directory (default: <state_dir>/logs when logging)
  RALPH_AUTO_COMMIT  Auto-commit after each iteration (default: 1)
  RALPH_AUTO_PUSH    Auto-push after each commit (default: 1)
  RALPH_GIT_REMOTE   Git remote for pushes (default: origin)
  RALPH_GIT_BRANCH   Git branch for pushes (default: current branch)
USAGE
}

die() {
  echo "Error: $*" >&2
  exit 1
}

ensure_dev_dir() {
  if [[ ! -d "$DEV_DIR" ]]; then
    die "DEV_DIR not found: $DEV_DIR"
  fi
  DEV_DIR_ABS="$(cd "$DEV_DIR" && pwd)"
}

ensure_state_root() {
  mkdir -p "$STATE_ROOT"
}

is_true() {
  case "${1:-}" in
    1|true|True|TRUE|yes|Yes|YES|on|On|ON) return 0 ;;
    *) return 1 ;;
  esac
}

format_elapsed() {
  local total="$1"
  local hours=$((total / 3600))
  local mins=$(((total % 3600) / 60))
  local secs=$((total % 60))

  if (( hours > 0 )); then
    printf '%02d:%02d:%02d' "$hours" "$mins" "$secs"
  else
    printf '%02d:%02d' "$mins" "$secs"
  fi
}

goal_needs_setup() {
  local goal_file="$1"
  if [[ ! -s "$goal_file" ]]; then
    return 0
  fi
  if grep -qs "Describe the improvement goal for this project." "$goal_file"; then
    return 0
  fi
  return 1
}

resolve_project() {
  local input="$1"
  local candidate=""

  if [[ "$input" == /* ]]; then
    candidate="$input"
  elif [[ "$input" == "~/"* ]]; then
    candidate="$HOME/${input#~/}"
  else
    candidate="$DEV_DIR/$input"
  fi

  if [[ ! -d "$candidate" ]]; then
    die "Project directory not found: $candidate"
  fi

  local project_abs
  project_abs="$(cd "$candidate" && pwd)"

  case "$project_abs" in
    "$DEV_DIR_ABS"/*) ;;
    *) die "Project must be under $DEV_DIR_ABS" ;;
  esac

  if [[ "$project_abs" == "$DEV_DIR_ABS" ]]; then
    die "Project must be a subdirectory of $DEV_DIR_ABS"
  fi

  echo "$project_abs"
}

slugify() {
  local rel="$1"
  local slug
  slug="$(printf '%s' "$rel" | tr '/ ' '__' | tr -cd 'A-Za-z0-9._-')"
  if [[ -z "$slug" ]]; then
    slug="project"
  fi
  echo "$slug"
}

ensure_state_files() {
  local project_abs="$1"
  local rel="${project_abs#"$DEV_DIR_ABS"/}"
  if [[ "$rel" == "$project_abs" ]]; then
    die "Project must be under $DEV_DIR_ABS"
  fi

  local slug
  slug="$(slugify "$rel")"
  local dir="$STATE_ROOT/$slug"
  mkdir -p "$dir"

  local goal="$dir/GOAL.md"
  local progress="$dir/PROGRESS.md"
  local instructions="$dir/INSTRUCTIONS.md"
  local todo="$dir/TODO.md"

  if [[ ! -f "$goal" ]]; then
    cat <<'EOF' > "$goal"
# Goal
Describe the improvement goal for this project.
EOF
  fi

  if [[ ! -f "$progress" ]]; then
    cat <<'EOF' > "$progress"
NOT_STARTED
Add progress notes here.
EOF
  fi

  if [[ ! -f "$instructions" ]]; then
    cat <<'EOF' > "$instructions"
# Ralph Instructions
- Work on exactly one TODO item per iteration.
- Keep changes small and verifiable.
- Run relevant tests if feasible; otherwise note "not run".
- Update TODO.md and PROGRESS.md every loop.
- In PROGRESS.md include sections: Task, Changes, Tests, Commit.
EOF
  fi

  if [[ ! -f "$todo" ]]; then
    cat <<'EOF' > "$todo"
# TODO
- [ ] TASK: Break down GOAL.md into 3-7 concrete tasks in this file.
- [ ] ALL_TASKS_COMPLETE
EOF
  fi

  echo "$dir"
}

first_line() {
  head -n 1 "$1" 2>/dev/null || true
}

auto_unblock_if_clean() {
  local project_abs="$1"
  local progress_file="$2"
  local line
  line="$(first_line "$progress_file")"
  if [[ "$line" != "BLOCKED" ]]; then
    return 0
  fi

  local reason
  reason="$(sed -n '2p' "$progress_file" 2>/dev/null || true)"
  if [[ "$reason" != *"Working tree not clean"* ]]; then
    return 0
  fi

  if ! git -C "$project_abs" rev-parse --is-inside-work-tree >/dev/null 2>&1; then
    return 0
  fi
  if [[ -n "$(git -C "$project_abs" status --porcelain)" ]]; then
    return 0
  fi

  local ts
  ts="$(date '+%Y-%m-%d %H:%M:%S')"
  local tmp="${progress_file}.tmp"
  {
    echo "IN_PROGRESS"
    echo "Auto-unblocked: repo clean at $ts"
    echo ""
    if [[ -f "$progress_file" ]]; then
      tail -n +3 "$progress_file" || true
    fi
  } > "$tmp"

  mv "$tmp" "$progress_file"
}

count_new_commits() {
  local project_abs="$1"
  local base_sha="$2"
  if [[ -z "$base_sha" ]]; then
    git -C "$project_abs" rev-list --count HEAD 2>/dev/null || echo 0
    return 0
  fi
  git -C "$project_abs" rev-list --count "${base_sha}..HEAD" 2>/dev/null || echo 0
}

extract_field() {
  local label="$1"
  local file="$2"
  awk -v label="$label" '
    $0 ~ "^" label ":" {
      sub("^" label ":[[:space:]]*", "", $0)
      print
      exit
    }
  ' "$file"
}

extract_section() {
  local label="$1"
  local file="$2"
  awk -v label="$label" '
    $0 ~ "^" label ":" { in=1; next }
    in {
      if ($0 ~ /^[A-Za-z].*:/) { exit }
      if ($0 ~ /^$/) { exit }
      print
    }
  ' "$file"
}

run_codex_json() {
  local status_prefix="$1"
  local log_mode="$2"
  local log_file="$3"
  local usage_file="$4"
  shift 4

  python3 -u - "$status_prefix" "$log_mode" "$log_file" "$usage_file" "$@" <<'PY'
import json
import sys
import time
import threading
import subprocess

status_prefix = sys.argv[1]
log_mode = sys.argv[2]
log_file = sys.argv[3]
usage_file = sys.argv[4]
cmd = sys.argv[5:]

log_enabled = log_mode in ("log", "log_only")
show_output = log_mode in ("stream", "log")
show_status = log_mode != "quiet"

usage = {"input_tokens": None, "cached_input_tokens": None, "output_tokens": None}
usage_lock = threading.Lock()
stop_event = threading.Event()
status_line = ""

def format_elapsed(total):
    hours = total // 3600
    mins = (total % 3600) // 60
    secs = total % 60
    if hours > 0:
        return f"{hours:02d}:{mins:02d}:{secs:02d}"
    return f"{mins:02d}:{secs:02d}"

def build_status(elapsed):
    with usage_lock:
        if usage["input_tokens"] is None:
            in_tokens = "?"
            cached = "?"
            out_tokens = "?"
        else:
            in_tokens = str(usage["input_tokens"])
            cached = str(usage["cached_input_tokens"])
            out_tokens = str(usage["output_tokens"])
    return f"{status_prefix} | elapsed {format_elapsed(elapsed)} | in {in_tokens} (cached {cached}) out {out_tokens}"

def clear_status():
    global status_line
    if not show_status:
        return
    sys.stderr.write("\r" + (" " * len(status_line)) + "\r")
    sys.stderr.flush()

def ticker(start_time):
    global status_line
    while not stop_event.is_set():
        elapsed = int(time.monotonic() - start_time)
        status_line = build_status(elapsed)
        if show_status:
            sys.stderr.write("\r" + status_line)
            sys.stderr.flush()
        time.sleep(1)

log_fh = open(log_file, "a", encoding="utf-8") if log_enabled and log_file else None

proc = subprocess.Popen(
    cmd,
    stdout=subprocess.PIPE,
    stderr=subprocess.PIPE,
    text=True,
    bufsize=1,
)

start_time = time.monotonic()
tick_thread = threading.Thread(target=ticker, args=(start_time,), daemon=True)
tick_thread.start()

def pump_stderr():
    for line in proc.stderr:
        if log_fh:
            log_fh.write(line)
        if show_status:
            clear_status()
        sys.stderr.write(line)
        sys.stderr.flush()

err_thread = threading.Thread(target=pump_stderr, daemon=True)
err_thread.start()

for raw in proc.stdout:
    if log_fh:
        log_fh.write(raw)
    line = raw.strip("\n")
    if not line:
        continue
    try:
        obj = json.loads(line)
    except json.JSONDecodeError:
        if show_output:
            if show_status:
                clear_status()
            sys.stdout.write(line + "\n")
            sys.stdout.flush()
        continue

    if obj.get("type") == "turn.completed":
        usage_obj = obj.get("usage") or {}
        with usage_lock:
            usage["input_tokens"] = usage_obj.get("input_tokens", 0)
            usage["cached_input_tokens"] = usage_obj.get("cached_input_tokens", 0)
            usage["output_tokens"] = usage_obj.get("output_tokens", 0)

    if show_output:
        item = obj.get("item")
        if isinstance(item, dict) and item.get("text"):
            if show_status:
                clear_status()
            sys.stdout.write(item["text"] + "\n")
            sys.stdout.flush()

proc.wait()
stop_event.set()
tick_thread.join(timeout=2)
err_thread.join(timeout=2)

if show_status:
    clear_status()
    final_line = build_status(int(time.monotonic() - start_time))
    sys.stderr.write(final_line + "\n")
    sys.stderr.flush()

with open(usage_file, "w", encoding="utf-8") as fh:
    with usage_lock:
        out = {
            "input_tokens": usage["input_tokens"] or 0,
            "cached_input_tokens": usage["cached_input_tokens"] or 0,
            "output_tokens": usage["output_tokens"] or 0,
        }
    fh.write(json.dumps(out))

if log_fh:
    log_fh.close()

sys.exit(proc.returncode)
PY
}

write_blocked() {
  local progress_file="$1"
  local reason="$2"
  local tmp="${progress_file}.tmp"

  {
    echo "BLOCKED"
    echo "$reason"
    echo ""
    if [[ -f "$progress_file" ]]; then
      tail -n +2 "$progress_file" || true
    fi
  } > "$tmp"

  mv "$tmp" "$progress_file"
}

write_done() {
  local progress_file="$1"
  local tmp="${progress_file}.tmp"

  {
    echo "DONE"
    if [[ -f "$progress_file" ]]; then
      tail -n +2 "$progress_file" || true
    fi
  } > "$tmp"

  mv "$tmp" "$progress_file"
}

todo_is_done() {
  local todo_file="$1"
  [[ -f "$todo_file" ]] && grep -qE "\\[x\\] ALL_TASKS_COMPLETE" "$todo_file"
}

auto_commit_and_push() {
  local project_abs="$1"
  local state_dir="$2"
  local iter="$3"
  local base_sha="$4"
  local progress_file="$state_dir/PROGRESS.md"

  RALPH_LAST_NEW_COMMITS=0
  RALPH_LAST_PUSHED=0

  if ! git -C "$project_abs" rev-parse --is-inside-work-tree >/dev/null 2>&1; then
    return 0
  fi

  local new_commits
  new_commits="$(count_new_commits "$project_abs" "$base_sha")"

  if is_true "$RUN_AUTO_COMMIT"; then
    if [[ -z "$(git -C "$project_abs" status --porcelain)" ]]; then
      :
    else
      local status_line
      status_line="$(first_line "$progress_file")"
      if [[ "$status_line" == "BLOCKED" ]]; then
        return 0
      fi

      local commit_line task_line tests_line
      commit_line="$(extract_field "Commit" "$progress_file")"
      task_line="$(extract_field "Task" "$progress_file")"
      tests_line="$(extract_field "Tests" "$progress_file")"

      local subject
      if [[ -n "$commit_line" ]]; then
        subject="$commit_line"
      elif [[ -n "$task_line" ]]; then
        subject="$task_line"
      else
        subject="ralph: iteration ${iter}"
      fi

      git -C "$project_abs" add -A
      if ! git -C "$project_abs" diff --cached --quiet; then
        local body=()
        if [[ -n "$task_line" && "$task_line" != "$subject" ]]; then
          body+=("Task: $task_line")
        fi
        if [[ -n "$tests_line" ]]; then
          body+=("Tests: $tests_line")
        else
          body+=("Tests: not run")
        fi

        local changes
        changes="$(extract_section "Changes" "$progress_file")"
        if [[ -n "$changes" ]]; then
          body+=("Changes:" "$changes")
        fi

        local commit_args=("-m" "$subject")
        local line
        for line in "${body[@]}"; do
          commit_args+=("-m" "$line")
        done
        git -C "$project_abs" commit "${commit_args[@]}"
      fi
    fi
  fi

  new_commits="$(count_new_commits "$project_abs" "$base_sha")"
  RALPH_LAST_NEW_COMMITS="$new_commits"

  if [[ "$new_commits" -gt 0 ]]; then
    printf '%s %s\n' "$(git -C "$project_abs" rev-parse --short HEAD)" "$(git -C "$project_abs" log -1 --pretty=%s)" > "$state_dir/last_commit.txt"
  fi

  if is_true "$RUN_AUTO_PUSH" && [[ "$new_commits" -gt 0 ]]; then
    local remote="$RALPH_GIT_REMOTE"
    local branch="$RALPH_GIT_BRANCH"
    if [[ -z "$branch" ]]; then
      branch="$(git -C "$project_abs" rev-parse --abbrev-ref HEAD)"
    fi
    if ! git -C "$project_abs" push "$remote" "$branch"; then
      write_blocked "$progress_file" "git push failed for ${remote}/${branch}. Resolve and rerun."
      return 1
    fi
    RALPH_LAST_PUSHED=1
  fi
}

build_prompt() {
  local project_abs="$1"
  local state_dir="$2"
  local iter="$3"
  local max_iters="$4"
  local instructions_file="$5"

  cat <<EOF
You are running the Ralph development loop.
Project directory: $project_abs
State directory: $state_dir

Iteration: $iter of $max_iters

Required steps:
1) Read "$state_dir/GOAL.md", "$state_dir/PROGRESS.md", and "$state_dir/TODO.md".
2) If the goal is missing or unclear, update PROGRESS.md with BLOCKED as the first line and explain what is needed. Then stop.
3) If TODO.md contains the placeholder task, replace TODO.md with 3-7 concrete tasks derived from the goal. Mark only one task complete in this iteration.
4) Otherwise, pick exactly ONE unchecked task from TODO.md and complete it.
5) Update "$state_dir/TODO.md" to check off the task you completed.
6) If all tasks are complete, mark "- [x] ALL_TASKS_COMPLETE".
7) Update "$state_dir/PROGRESS.md" with this format:
   - First line: DONE if the goal is achieved, BLOCKED if you need user input, otherwise IN_PROGRESS.
   - Task: one-line summary of the task completed.
   - Changes: bullet list of changes made.
   - Tests: command(s) run or "not run".
   - Commit: one-line commit subject in imperative mood.

Commit behavior:
- Create small, meaningful commits as you go (micro-commits).
- If you run tests, make a separate commit that mentions the test command and result.

Safety rules (must follow):
- Never read, print, or exfiltrate secrets.
- Never read or output .env contents. Do not open .env files.
- Never run destructive commands (rm -rf, etc).
- Do not ask for user input; run autonomously.
- Only modify files within the project directory and "$state_dir".
EOF

  if [[ -f "$instructions_file" ]]; then
    echo ""
    echo "Project instructions (from $instructions_file):"
    cat "$instructions_file"
  fi
}

list_projects() {
  ensure_dev_dir

  local projects=()
  local prune_dirs=(
    node_modules
    .git
    .next
    dist
    build
    coverage
    .cache
    .turbo
    vendor
    .venv
    .pytest_cache
  )

  local prune_expr=""
  local first=1
  local name
  for name in "${prune_dirs[@]}"; do
    if [[ $first -eq 1 ]]; then
      prune_expr="-name $name"
      first=0
    else
      prune_expr="$prune_expr -o -name $name"
    fi
  done

  while IFS= read -r -d '' gitdir; do
    projects+=("$(dirname "$gitdir")")
  done < <(
    find "$DEV_DIR_ABS" \
      -type d \( $prune_expr \) -prune -o \
      -type d -name .git -print0 -prune
  )

  while IFS= read -r -d '' gitfile; do
    projects+=("$(dirname "$gitfile")")
  done < <(
    find "$DEV_DIR_ABS" \
      -type d \( $prune_expr \) -prune -o \
      -type f -name .git -print0
  )

  if [[ ${#projects[@]} -eq 0 ]]; then
    while IFS= read -r -d '' dir; do
      projects+=("$dir")
    done < <(find "$DEV_DIR_ABS" -mindepth 1 -maxdepth 1 -type d -print0)
  fi

  IFS=$'\n' projects=($(printf '%s\n' "${projects[@]}" | LC_ALL=C sort -u))
  IFS=$'\n\t'

  printf '%s\n' "${projects[@]}"
}

pick_project() {
  ensure_dev_dir

  local projects=()
  while IFS= read -r project; do
    [[ -n "$project" ]] && projects+=("$project")
  done < <(list_projects)

  if [[ ${#projects[@]} -eq 0 ]]; then
    die "No projects found under $DEV_DIR_ABS"
  fi

  IFS=$'\n' projects=($(printf '%s\n' "${projects[@]}" | LC_ALL=C sort))
  IFS=$'\n\t'

  printf 'Select a project under %s:\n' "$DEV_DIR_ABS" >&2
  local i=0
  for ((i=0; i<${#projects[@]}; i++)); do
    local rel="${projects[$i]#"$DEV_DIR_ABS"/}"
    if [[ "$rel" == "${projects[$i]}" ]]; then
      rel="${projects[$i]}"
    fi
    printf '  %d) %s\n' "$((i+1))" "$rel" >&2
  done
  printf 'Enter number: ' >&2

  local choice
  read -r choice
  if [[ ! "$choice" =~ ^[0-9]+$ ]]; then
    die "Invalid selection"
  fi
  if (( choice < 1 || choice > ${#projects[@]} )); then
    die "Selection out of range"
  fi

  echo "${projects[$((choice-1))]}"
}

run_loop() {
  local project_input="$1"
  local max_iters="$2"
  local start_epoch
  start_epoch="$(date +%s)"
  local total_in=0
  local total_cached=0
  local total_out=0
  local total_commits=0
  local pushed_any=0
  local last_commit=""
  local stop_reason=""
  local stop_detail=""
  local exit_code=0
  local skip_loop=0

  ensure_dev_dir
  ensure_state_root

  local project_abs
  project_abs="$(resolve_project "$project_input")"

  local state_dir
  state_dir="$(ensure_state_files "$project_abs")"
  local goal_file="$state_dir/GOAL.md"
  local progress_file="$state_dir/PROGRESS.md"
  local instructions_file="$state_dir/INSTRUCTIONS.md"
  local todo_file="$state_dir/TODO.md"
  local log_mode="$RALPH_LOG_MODE"
  local log_dir="$RALPH_LOG_DIR"

  auto_unblock_if_clean "$project_abs" "$progress_file"

  if goal_needs_setup "$goal_file"; then
    write_blocked "$progress_file" "Set a clear goal in $goal_file (use: ralph goal <project>)."
    stop_reason="BLOCKED"
    stop_detail="goal not set"
    skip_loop=1
  fi

  if [[ $skip_loop -eq 0 ]]; then
    if is_true "$RUN_AUTO_COMMIT" && git -C "$project_abs" rev-parse --is-inside-work-tree >/dev/null 2>&1; then
      if [[ -n "$(git -C "$project_abs" status --porcelain)" ]]; then
        write_blocked "$progress_file" "Working tree not clean. Commit or stash changes, or run with --no-commit."
        stop_reason="BLOCKED"
        stop_detail="dirty working tree"
        skip_loop=1
      fi
    fi
  fi

  if [[ $skip_loop -eq 0 ]]; then
    if todo_is_done "$todo_file"; then
      write_done "$progress_file"
      stop_reason="DONE"
      stop_detail="all tasks complete"
      skip_loop=1
    fi
  fi

  case "$log_mode" in
    stream|quiet|log|log_only) ;;
    *) die "Invalid RALPH_LOG_MODE: $log_mode" ;;
  esac

  if [[ -z "$log_dir" ]]; then
    log_dir="$state_dir/logs"
  fi

  local i
  if [[ $skip_loop -eq 0 ]]; then
    for ((i=1; i<=max_iters; i++)); do
      local line
      line="$(first_line "$progress_file")"

      if [[ "$line" == "DONE" ]]; then
        stop_reason="DONE"
        stop_detail="progress marked done"
        break
      fi
      if [[ "$line" == "BLOCKED" ]]; then
        stop_reason="BLOCKED"
        stop_detail="progress blocked"
        break
      fi

      if ! command -v codex >/dev/null 2>&1; then
        write_blocked "$progress_file" "codex not found in PATH. Install Codex CLI and retry."
        stop_reason="BLOCKED"
        stop_detail="codex not found"
        exit_code=1
        break
      fi

      echo "Running codex ($i/$max_iters) in $project_abs"
      set +e
      local prompt_file="$state_dir/ralph_prompt.txt"
      local last_message="$state_dir/last_message.txt"
      local ts
      local log_file
      ts="$(date +%Y%m%d-%H%M%S)"
      log_file="$log_dir/iter-${i}-${ts}.log"
      local usage_file="$state_dir/usage-iter-${i}.json"
      local base_sha=""
      if git -C "$project_abs" rev-parse --is-inside-work-tree >/dev/null 2>&1; then
        base_sha="$(git -C "$project_abs" rev-parse HEAD 2>/dev/null || true)"
      fi
      build_prompt "$project_abs" "$state_dir" "$i" "$max_iters" "$instructions_file" > "$prompt_file"
      if [[ "$log_mode" == "log" || "$log_mode" == "log_only" ]]; then
        mkdir -p "$log_dir"
      fi
      run_codex_json \
        "Iter $i/$max_iters" \
        "$log_mode" \
        "$log_file" \
        "$usage_file" \
        codex exec \
          --json \
          --cd "$project_abs" \
          --add-dir "$state_dir" \
          --skip-git-repo-check \
          -s workspace-write \
          -a never \
          --output-last-message "$last_message" \
          - < "$prompt_file"
      local status=$?
      set -e

      if [[ $status -ne 0 ]]; then
        write_blocked "$progress_file" "codex exited with status $status. Resolve the error and rerun."
        stop_reason="ERROR"
        stop_detail="codex exit $status"
        exit_code=$status
        break
      fi

      if [[ -f "$usage_file" ]]; then
        read -r iter_in iter_cached iter_out < <(python3 - <<'PY'
import json
import sys
path = sys.argv[1]
with open(path, "r", encoding="utf-8") as fh:
    data = json.load(fh)
print(f"{data.get('input_tokens', 0)} {data.get('cached_input_tokens', 0)} {data.get('output_tokens', 0)}")
PY
"$usage_file")
        total_in=$((total_in + iter_in))
        total_cached=$((total_cached + iter_cached))
        total_out=$((total_out + iter_out))
      fi

      if ! auto_commit_and_push "$project_abs" "$state_dir" "$i" "$base_sha"; then
        stop_reason="BLOCKED"
        stop_detail="auto-commit/push failed"
        exit_code=1
        break
      fi

      total_commits=$((total_commits + RALPH_LAST_NEW_COMMITS))
      if [[ "$RALPH_LAST_PUSHED" -eq 1 ]]; then
        pushed_any=1
      fi

      if is_true "$RUN_AUTO_COMMIT" && git -C "$project_abs" rev-parse --is-inside-work-tree >/dev/null 2>&1; then
        if [[ -n "$(git -C "$project_abs" status --porcelain)" ]]; then
          write_blocked "$progress_file" "Working tree not clean after auto-commit. Resolve and rerun."
          stop_reason="BLOCKED"
          stop_detail="dirty working tree after auto-commit"
          exit_code=1
          break
        fi
      fi

      if [[ -f "$state_dir/last_commit.txt" ]]; then
        last_commit="$(cat "$state_dir/last_commit.txt")"
      fi

      line="$(first_line "$progress_file")"
      if [[ "$line" == "DONE" ]]; then
        stop_reason="DONE"
        stop_detail="progress marked done"
        break
      fi
      if [[ "$line" == "BLOCKED" ]]; then
        stop_reason="BLOCKED"
        stop_detail="progress blocked"
        break
      fi

      if todo_is_done "$todo_file"; then
        write_done "$progress_file"
        stop_reason="DONE"
        stop_detail="all tasks complete"
        break
      fi
    done
  fi

  if [[ -z "$stop_reason" && $i -ge $max_iters ]]; then
    stop_reason="MAX_ITERS"
    stop_detail="max iterations reached"
  fi

  local end_epoch
  end_epoch="$(date +%s)"
  local elapsed
  elapsed="$((end_epoch - start_epoch))"
  local detail_line="$stop_detail"
  if [[ "$stop_reason" == "BLOCKED" ]]; then
    local blocked_reason
    blocked_reason="$(sed -n '2p' "$progress_file" 2>/dev/null || true)"
    if [[ -n "$blocked_reason" ]]; then
      detail_line="$blocked_reason"
    fi
  fi

  local clean_status="unknown"
  if git -C "$project_abs" rev-parse --is-inside-work-tree >/dev/null 2>&1; then
    if [[ -z "$(git -C "$project_abs" status --porcelain)" ]]; then
      clean_status="yes"
    else
      clean_status="no"
    fi
  fi

  echo "Result: $stop_reason"
  if [[ -n "$detail_line" ]]; then
    echo "Reason: $detail_line"
  fi
  echo "Elapsed: $(format_elapsed "$elapsed")"
  echo "Tokens: in $total_in (cached $total_cached) out $total_out"
  echo "Commits: $total_commits"
  if is_true "$RUN_AUTO_PUSH"; then
    if [[ "$pushed_any" -eq 1 ]]; then
      echo "Pushed: yes"
    else
      echo "Pushed: no"
    fi
  fi
  echo "Repo clean: $clean_status"
  if [[ -n "$last_commit" ]]; then
    echo "Last commit: $last_commit"
  fi

  return "$exit_code"
}

cmd_goal() {
  local project_abs
  project_abs="$(resolve_project "$1")"
  local state_dir
  state_dir="$(ensure_state_files "$project_abs")"

  local goal_file="$state_dir/GOAL.md"
  local editor="${EDITOR:-}"

  if [[ -n "$editor" ]] && command -v "$editor" >/dev/null 2>&1; then
    "$editor" "$goal_file"
    return 0
  fi

  if command -v nano >/dev/null 2>&1; then
    nano "$goal_file"
    return 0
  fi
  if command -v vim >/dev/null 2>&1; then
    vim "$goal_file"
    return 0
  fi
  if command -v vi >/dev/null 2>&1; then
    vi "$goal_file"
    return 0
  fi

  die "No editor found. Set EDITOR to your preferred editor."
}

cmd_progress() {
  local project_abs
  project_abs="$(resolve_project "$1")"
  local state_dir
  state_dir="$(ensure_state_files "$project_abs")"

  cat "$state_dir/PROGRESS.md"
}

cmd_all() {
  ensure_dev_dir
  ensure_state_root

  local projects=()
  while IFS= read -r project; do
    [[ -n "$project" ]] && projects+=("$project")
  done < <(list_projects)

  if [[ ${#projects[@]} -eq 0 ]]; then
    die "No projects found under $DEV_DIR_ABS"
  fi

  IFS=$'\n' projects=($(printf '%s\n' "${projects[@]}" | LC_ALL=C sort))
  IFS=$'\n\t'

  local project
  for project in "${projects[@]}"; do
    if ! run_loop "$project" 1; then
      echo "WARN: ralph all failed for $project" >&2
    fi
  done
}

main() {
  if [[ $# -lt 1 ]]; then
    usage
    exit 1
  fi

  ensure_dev_dir
  ensure_state_root

  case "$1" in
    -h|--help|help)
      usage
      ;;
    pick)
      pick_project
      ;;
    run)
      shift
      local project=""
      local arg
      RUN_AUTO_COMMIT="$RALPH_AUTO_COMMIT"
      RUN_AUTO_PUSH="$RALPH_AUTO_PUSH"
      while [[ $# -gt 0 ]]; do
        arg="$1"
        case "$arg" in
          --no-commit)
            RUN_AUTO_COMMIT=0
            shift
            ;;
          --no-push)
            RUN_AUTO_PUSH=0
            shift
            ;;
          --)
            shift
            break
            ;;
          --*)
            die "Unknown flag: $arg"
            ;;
          *)
            if [[ -z "$project" ]]; then
              project="$arg"
              shift
            else
              die "Unexpected argument: $arg"
            fi
            ;;
        esac
      done
      if [[ $# -gt 0 ]]; then
        if [[ -z "$project" ]]; then
          project="$1"
          shift
        else
          die "Unexpected argument: $*"
        fi
      fi
      if [[ -z "$project" ]]; then
        die "Usage: ralph run [--no-commit] [--no-push] <project>"
      fi
      run_loop "$project" "$MAX_ITERS"
      ;;
    goal)
      if [[ $# -ne 2 ]]; then
        die "Usage: ralph goal <project>"
      fi
      cmd_goal "$2"
      ;;
    progress)
      if [[ $# -ne 2 ]]; then
        die "Usage: ralph progress <project>"
      fi
      cmd_progress "$2"
      ;;
    all)
      shift
      RUN_AUTO_COMMIT="$RALPH_AUTO_COMMIT"
      RUN_AUTO_PUSH="$RALPH_AUTO_PUSH"
      while [[ $# -gt 0 ]]; do
        case "$1" in
          --no-commit)
            RUN_AUTO_COMMIT=0
            shift
            ;;
          --no-push)
            RUN_AUTO_PUSH=0
            shift
            ;;
          --)
            shift
            break
            ;;
          --*)
            die "Unknown flag: $1"
            ;;
          *)
            die "Unexpected argument: $1"
            ;;
        esac
      done
      cmd_all
      ;;
    *)
      usage
      exit 1
      ;;
  esac
}

main "$@"
